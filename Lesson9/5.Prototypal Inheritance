Prototypal Inheritance

For the next quiz, consider the following two code snippets below (i.e., A and B):

// (A)

function Dalmatian (name) {
  this.name = name;

  this.bark = function() {
    console.log(`${this.name} barks!`);
  };
}

// (B)

function Dalmatian (name) {
  this.name = name;
}

Dalmatian.prototype.bark = function() {
  console.log(`${this.name} barks!`);
};

Question 1 of 5

Let's say that we want to define a method that can be invoked on instances (objects) of the Dalmatian constructor function (we'll be instantiating at least 101 of them!).

Which of the preceding two approaches is optimal?

(B) is optimal, because the function that bark points to does not need to be recreated each time an instance of Dalmatian is created.


Thanks for completing that!

While both approaches work just fine (i.e., any instances created by the constructor function will be able to invoke a bark() method), the second approach is more ideal. By adding methods to the prototype, memory is saved as more Dalmatian objects are instantiated. Along with being more efficient, we also don't have to update all objects individually should be decide to change a method.

+++++++++++++++

Question 2 of 5

What is true about hasOwnProperty()? Select all that apply:

It returns a boolean indicating whether the object has the specified property as its own property (i.e., the property isn't inherited)

hasOwnProperty() is invoked as a method onto an object
****
Thanks for completing that!

hasOwnProperty() takes in a single argument (i.e. the property to be checked), and the method is invoked directly on an object.


+++++

Question 3 of 5

What is true about isPrototypeOf() or getPrototypeOf()? Select all that apply:

    isPrototypeOf() checks whether or not an object exists in another object's prototype chain

    isPrototypeOf() takes a single argument: an object whose prototype chain is to be searched

    getPrototypeOf() returns the prototype of the object passed into it



Thanks for completing that!

For a closer look at isPrototypeOf() and getPrototypeOf, feel free to check out their MDN pages (linked).
****
Question 4 of 5

What is true about constructor property? Select all that apply:

    Accessing an object's constructor property returns a reference to the constructor function that created that object (instance)

Every object has a constructor property

Objects created with literal notation are constructed with the Object() constructor function


Thanks for completing that!

All objects have a constructor property. For a closer look, feel free to check out its article on MDN (linked).
*************
Question 5 of 5

Let's say that we create the following object, capitals, using regular object literal notation:

const capitals = {
  California: 'Sacramento',
  Washington: 'Olympia',
  Oregon: 'Salem',
  Texas: 'Austin'
};

What is returned when Object.getPrototypeOf(capitals); is executed?

    A reference to Object()'s prototype


Thanks for completing that!

This one may have been tricky! Keep in mind that since capitals was created with object literal notation, its constructor is the built-in Object() constructor function itself! As such, it maintains a reference to its constructor's prototype. That is,

Object.getPrototypeOf(capitals) === Object.prototype

// true
+++++++++++++++++++++==
We also looked at a few methods and properties that allow use to check the origins and references of objects and their prototypes, namely:

    hasOwnProperty()
    isPrototypeOf()
    Object.getPrototypeOf()
    .constructor





